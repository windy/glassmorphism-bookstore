require 'ostruct'

class AdminCrudGenerator < Rails::Generators::NamedBase
  source_root File.expand_path('templates', __dir__)

  def check_model_exists
    unless model_class_exists?
      say "Error: Model '#{class_name}' does not exist.", :red
      say "Please create the model first using: rails generate model #{class_name} [field:type ...]", :yellow
      exit(1)
    end
  end

  def generate_controller
    template "controller.rb.erb", "app/controllers/admin/#{plural_name}_controller.rb"
  end

  def generate_views
    template "views/index.html.erb", "app/views/admin/#{plural_name}/index.html.erb"
    template "views/show.html.erb", "app/views/admin/#{plural_name}/show.html.erb"
    template "views/new.html.erb", "app/views/admin/#{plural_name}/new.html.erb"
    template "views/edit.html.erb", "app/views/admin/#{plural_name}/edit.html.erb"
  end

  def add_routes
    route "resources :#{plural_name}", namespace: :admin
  end

  def update_sidebar
    sidebar_path = "app/views/shared/admin/_sidebar.html.erb"
    if File.exist?(sidebar_path)
      sidebar_content = File.read(sidebar_path)
      
      # Check if menu item already exists
      generated_comment = "<!-- Generated by admin_crud: #{plural_name} -->"
      if sidebar_content.include?(generated_comment)
        say "Sidebar already contains #{humanized_plural_name} menu item, skipping...", :yellow
        return
      end
      
      # Add menu item to the end of the file
      menu_item = <<~MENU_ITEM

        #{generated_comment}
        <li>
          <%= link_to admin_#{plural_name}_path, 
              class: "\#{'active' if current_path.include?('/admin/#{plural_name}')}" do %>
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd"/>
            </svg>
            #{humanized_plural_name}
          <% end %>
        </li>
      MENU_ITEM
      
      updated_content = sidebar_content + menu_item
      File.write(sidebar_path, updated_content)
      say "Updated admin sidebar with #{humanized_plural_name} menu item", :green
    else
      say "Warning: Admin sidebar file not found. Please manually add menu item for #{humanized_plural_name}", :yellow
    end
  end

  private

  def model_class_exists?
    begin
      class_name.constantize
      true
    rescue NameError
      false
    end
  end

  def model_class
    @model_class ||= class_name.constantize
  end

  def singular_name
    name.underscore.singularize
  end

  def plural_name
    name.underscore.pluralize
  end

  def class_name
    name.classify
  end

  def humanized_name
    singular_name.humanize
  end

  def humanized_plural_name
    plural_name.humanize
  end

  def model_columns
    @model_columns ||= model_class.columns.reject do |column|
      %w[id created_at updated_at].include?(column.name)
    end
  end

  def model_attributes
    @model_attributes ||= model_columns.map do |column|
      OpenStruct.new(
        name: column.name,
        type: column.type,
        sql_type: column.sql_type,
        null: column.null,
        default: column.default
      )
    end
  end

  def permit_params
    model_attributes.map(&:name).map { |name| ":#{name}" }.join(', ')
  end

  def display_attributes
    # Return first few attributes for table display, prioritizing string/text fields
    attrs = model_attributes.select { |attr| %w[string text].include?(attr.type.to_s) }
    attrs = model_attributes if attrs.empty?
    attrs.first(3) # Limit to first 3 for table display
  end

  def form_field_for(attribute)
    case attribute.type.to_s
    when 'text'
      "text_area"
    when 'boolean'
      "check_box"
    when 'integer', 'decimal', 'float'
      "number_field"
    when 'date'
      "date_field"
    when 'datetime', 'timestamp'
      "datetime_local_field"
    when 'time'
      "time_field"
    else
      "text_field"
    end
  end

  def input_class_for(attribute)
    case attribute.type.to_s
    when 'text'
      "textarea"
    when 'boolean'
      "checkbox"
    else
      "input"
    end
  end

  def display_value_for(attribute, instance_var)
    case attribute.type.to_s
    when 'text'
      "simple_format(#{instance_var}.#{attribute.name})"
    when 'boolean'
      "#{instance_var}.#{attribute.name} ? 'Yes' : 'No'"
    when 'date', 'datetime', 'timestamp'
      "#{instance_var}.#{attribute.name}&.strftime('%Y-%m-%d %H:%M')"
    else
      "#{instance_var}.#{attribute.name}"
    end
  end

  def truncate_value_for(attribute, instance_var)
    case attribute.type.to_s
    when 'text'
      "truncate(#{instance_var}.#{attribute.name}, length: 100)"
    else
      "#{instance_var}.#{attribute.name}"
    end
  end

  def attribute_required?(attribute)
    # Check model validations for presence requirement
    model_class.validators_on(attribute.name.to_sym).any? do |validator|
      validator.is_a?(ActiveModel::Validations::PresenceValidator)
    end
  end

  def get_validation_info(attribute)
    # Get validation information for better form generation
    validators = model_class.validators_on(attribute.name.to_sym)
    info = {
      required: false,
      length_max: nil,
      length_min: nil,
      format: nil
    }
    
    validators.each do |validator|
      case validator
      when ActiveModel::Validations::PresenceValidator
        info[:required] = true
      when ActiveModel::Validations::LengthValidator
        info[:length_max] = validator.options[:maximum] if validator.options[:maximum]
        info[:length_min] = validator.options[:minimum] if validator.options[:minimum]
      when ActiveModel::Validations::FormatValidator
        info[:format] = validator.options[:with] if validator.options[:with]
      end
    end
    
    info
  end
end
